// @todo When building walls or ramparts, try to immediately repair them a little as well.

var utilities = require('utilities');

Creep.prototype.performGetExploitEnergy = function () {
    // Find nearby energy on the ground.
    if (!this.memory.energyTarget) {
        var energy = this.pos.findInRange(FIND_DROPPED_RESOURCES, 3, {
            filter: (energy) => energy.amount > this.carryCapacity * 0.3 && energy.resourceType == RESOURCE_ENERGY
        });
        if (energy.length > 0) {
            // Cache target energy to avoid ping-pong between it and target source.
            this.memory.energyTarget = energy[0].id;
        }
    }
    if (this.memory.energyTarget) {
        let energy = Game.getObjectById(this.memory.energyTarget);
        if (!energy) {
            delete this.memory.energyTarget;
        }
        else {
            if (this.pos.getRangeTo(energy) > 1) {
                this.moveToRange(energy, 1);
            }
            else {
                this.pickup(energy);
            }
            return true;
        }
    }

    // Harvest from safe sources.
    var source = this.pos.findClosestByRange(FIND_SOURCES_ACTIVE, {
        filter: (source) => !source.isDangerous()
    });

    if (source) {
        let container = source.getNearbyContainer();
        if (container && container.store.energy > this.carryCapacity * 0.5) {
            if (this.pos.getRangeTo(container) > 1) {
                this.moveToRange(container, 1);
            }
            else {
                this.withdraw(container, RESOURCE_ENERGY);
            }
            return true;
        }

        if (this.pos.getRangeTo(source) > 1) {
            this.moveToRange(source, 1);
        }
        else {
            this.harvest(source);
        }
        return true;
    }
};

/**
 * Makes the creep use energy to finish construction sites in the current room.
 */
Creep.prototype.performExploitBuild = function () {
    // Repair structures around the room when necessary.
    if (!this.memory.repairTarget && Game.time % 10 == 0) {
        let structure = this.pos.findClosestByRange(FIND_STRUCTURES, {
            filter: (structure) => structure.hits && structure.hits < structure.hitsMax * 0.5
        });

        if (structure) {
            this.memory.repairTarget = structure.id;
            delete this.memory.buildTarget;
        }
    }
    if (this.memory.repairTarget) {
        var target = Game.getObjectById(this.memory.repairTarget);
        if (!target) {
            delete this.memory.repairTarget;
        }
        else {
            if (target.hits >= target.hitsMax) {
                delete this.memory.repairTarget;
            }
            else if (this.pos.getRangeTo(target) > 3) {
                this.moveToRange(target, 3);
                if (Game.cpu.bucket > 5000) {
                    this.repairNearby();
                }
            }
            else {
                this.repair(target);
            }
            return true;
        }
    }

    // Build stuff in the room.
    if (!this.memory.buildTarget) {
        var targets = this.room.find(FIND_CONSTRUCTION_SITES);
        if (targets.length <= 0) {
            return false;
        }

        this.memory.buildTarget = utilities.getClosest(this, targets);
    }
    var best = this.memory.buildTarget;
    if (!best) {
        return false;
    }
    var target = Game.getObjectById(best);
    if (!target) {
        this.memory.buildTarget = null;
        return false;
    }

    if (this.pos.getRangeTo(target) > 3) {
        this.moveToRange(target, 3);
        if (Game.cpu.bucket > 5000) {
            this.repairNearby();
        }
    }
    else {
        this.build(target);
    }
    return true;
};

/**
 * Puts this creep into or out of build mode.
 */
Creep.prototype.setExploitBuilderState = function (building) {
    this.memory.building = building;
    delete this.memory.buildTarget;
    delete this.memory.resourceTarget;
    delete this.memory.tempRole;
};

/**
 * Makes a creep behave like an exploit builder.
 */
Creep.prototype.runExploitBuilderLogic = function () {
    if (this.memory.building && this.carry.energy == 0) {
        this.setExploitBuilderState(false);
    }
    else if (!this.memory.building && this.carry.energy == this.carryCapacity) {
        this.setExploitBuilderState(true);
    }

    var exploit = Game.exploits[this.memory.exploitName];
    if (exploit) {
        // Follow cached path when requested.
        if (this.hasCachedPath()) {
            this.followCachedPath();
            if (this.hasArrived()) {
                this.clearCachedPath();
            }
            else {
                return true;
            }
        }
        else if (this.pos.roomName != exploit.roomName && exploit.memory.pathToRoom) {
            this.setCachedPath(exploit.memory.pathToRoom, false, 3);
            return true;
        }
    }

    if (this.memory.building) {
        return this.performExploitBuild();
    }
    else {
        return this.performGetExploitEnergy();
    }
};
