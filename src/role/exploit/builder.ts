/* global FIND_DROPPED_RESOURCES RESOURCE_ENERGY FIND_SOURCES_ACTIVE
FIND_STRUCTURES FIND_MY_CONSTRUCTION_SITES */

import utilities from 'utilities';
import Role from 'role/role';
import BuilderRole from 'role/builder';

export default class ExploitBuilderRole extends Role {
	builderRole: BuilderRole;

	constructor() {
		super();

		this.builderRole = new BuilderRole();
	}

	/**
	 * Makes a creep behave like an exploit builder.
	 *
	 * @param {Creep} creep
	 *   The creep to run logic for.
	 */
	run(creep) {
		if (creep.memory.building && creep.store[RESOURCE_ENERGY] === 0) {
			this.setExploitBuilderState(creep, false);
		}
		else if (!creep.memory.building && creep.store[RESOURCE_ENERGY] === creep.store.getCapacity()) {
			this.setExploitBuilderState(creep, true);
		}

		const exploit = Game.exploits[creep.memory.exploitName];
		if (exploit) {
			// Follow cached path when requested.
			if (creep.hasCachedPath()) {
				creep.followCachedPath();
				if (creep.hasArrived()) {
					creep.clearCachedPath();
				}
				else {
					return;
				}
			}
			else if (creep.pos.roomName !== exploit.roomName && exploit.memory.pathToRoom) {
				creep.setCachedPath(exploit.memory.pathToRoom, false, 3);
				return;
			}
		}

		if (creep.memory.building) {
			this.performExploitBuild(creep);
			return;
		}

		this.performGetExploitEnergy(creep);
	}

	/**
	 * Puts this creep into or out of build mode.
	 *
	 * @param {Creep} creep
	 *   The creep to run logic for.
	 * @param {boolean} building
	 *   Whether to start building or not.
	 */
	setExploitBuilderState(creep, building) {
		creep.memory.building = building;
		delete creep.memory.buildTarget;
		delete creep.memory.resourceTarget;
	}

	/**
	 * Makes the creep use energy to finish construction sites in the current room.
	 *
	 * @param {Creep} creep
	 *   The creep to run logic for.
	 */
	performExploitBuild(creep) {
		// Repair structures around the room when necessary.
		if (!creep.memory.repairTarget && Game.time % 10 === 0) {
			const structure = creep.pos.findClosestByRange(FIND_STRUCTURES, {
				filter: structure => structure.hits && structure.hits < structure.hitsMax * 0.5,
			});

			if (structure) {
				creep.memory.repairTarget = structure.id;
				delete creep.memory.buildTarget;
			}
		}

		if (creep.memory.repairTarget) {
			const target = Game.getObjectById<AnyOwnedStructure>(creep.memory.repairTarget);
			if (target) {
				if (target.hits >= target.hitsMax) {
					delete creep.memory.repairTarget;
				}
				else if (creep.pos.getRangeTo(target) > 3) {
					creep.moveToRange(target, 3);
					if (Game.cpu.bucket > 5000) {
						this.builderRole.repairNearby(creep);
					}
				}
				else {
					creep.repair(target);
				}

				return;
			}

			delete creep.memory.repairTarget;
		}

		// Build stuff in the room.
		if (!creep.memory.buildTarget) {
			const targets = creep.room.find(FIND_MY_CONSTRUCTION_SITES);
			if (targets.length <= 0) {
				return;
			}

			creep.memory.buildTarget = utilities.getClosest(creep, targets);
		}

		const best = creep.memory.buildTarget;
		if (!best) {
			return;
		}

		const target = Game.getObjectById(best);
		if (!target) {
			creep.memory.buildTarget = null;
			return;
		}

		if (creep.pos.getRangeTo(target) > 3) {
			creep.moveToRange(target, 3);
			if (Game.cpu.bucket > 5000) {
				this.builderRole.repairNearby(creep);
			}
		}
		else {
			creep.build(target);
		}
	}

	/**
	 * Gathers energy while on an exploit operation.
	 *
	 * @param {Creep} creep
	 *   The creep to run logic for.
	 */
	performGetExploitEnergy(creep) {
		// Find nearby energy on the ground.
		if (!creep.memory.energyTarget) {
			const energy = creep.pos.findInRange(FIND_DROPPED_RESOURCES, 3, {
				filter: energy => energy.amount > creep.store.getCapacity() * 0.1 && energy.resourceType === RESOURCE_ENERGY,
			});
			if (energy.length > 0) {
				// Cache target energy to avoid ping-pong between it and target source.
				creep.memory.energyTarget = energy[0].id;
			}
			else {
				const tombs = creep.pos.findInRange(FIND_TOMBSTONES, 3, {
					filter: tomb => tomb.store.getUsedCapacity(RESOURCE_ENERGY) > creep.store.getCapacity() * 0.1
				});
				if (tombs.length > 0) {
					// Cache target tombs to avoid ping-pong between it and target source.
					creep.memory.energyTarget = tombs[0].id;
				}
			}
		}

		if (creep.memory.energyTarget) {
			const energy = Game.getObjectById<Resource | Tombstone>(creep.memory.energyTarget);
			if (energy && ('amount' in energy ? energy.amount : energy.store.getUsedCapacity(RESOURCE_ENERGY)) > 0) {
				creep.whenInRange(1, energy, () => {
					if (energy instanceof Tombstone) {
						if (creep.withdraw(energy, RESOURCE_ENERGY) === OK) delete creep.memory.energyTarget;
					}
					else {
						if (creep.pickup(energy) === OK) delete creep.memory.energyTarget;
					}
				});

				return;
			}

			delete creep.memory.energyTarget;
		}

		// Harvest from safe sources.
		const source = creep.pos.findClosestByRange(FIND_SOURCES_ACTIVE, {
			filter: source => !source.isDangerous(),
		});

		if (!source) return;

		const container = source.getNearbyContainer();
		if (container && container.store[RESOURCE_ENERGY] > creep.store.getCapacity() * 0.5) {
			creep.whenInRange(1, container, () => {
				creep.withdraw(container, RESOURCE_ENERGY);
			});

			return;
		}

		creep.whenInRange(1, source, () => {
			creep.harvest(source);
		});
	}
}
