'use strict';

/* global COLOR_RED STRUCTURE_KEEPER_LAIR FIND_SOURCES FIND_MINERALS
RESOURCE_ENERGY FIND_CONSTRUCTION_SITES LOOK_STRUCTURES LOOK_CONSTRUCTION_SITES
STRUCTURE_ROAD OK MOVE ATTACK HEAL STRUCTURE_CONTAINER */

const utilities = require('utilities');

const Exploit = function (room, flagName) {
	const flag = Game.flags[flagName];
	const roomName = flag.pos.roomName;
	this.units = {};
	this.name = roomName;
	this.roomName = roomName;
	this.flag = flag;

	this.sourceRoom = room;

	// Prepare memory
	if (!Memory.exploits) {
		Memory.exploits = {};
	}

	if (!Memory.exploits[roomName]) {
		Memory.exploits[roomName] = {};
	}

	this.memory = Memory.exploits[roomName];

	// Adjust flag color.
	if (this.flag.color !== COLOR_RED) {
		this.flag.setColor(COLOR_RED);
	}

	// Collect creeps from temp data.
	if (Game.exploitTemp && Game.exploitTemp[this.name]) {
		for (let i in Game.exploitTemp[this.name]) {
			const creep = Game.getObjectById(Game.exploitTemp[this.name][i]);

			if (!this.units[creep.memory.exploitUnitType]) {
				this.units[creep.memory.exploitUnitType] = [];
			}

			this.units[creep.memory.exploitUnitType].push(creep);
		}
	}

	// Collect source keeper lair positions.
	if (!this.memory.lairs && Memory.rooms[this.roomName] && Memory.rooms[this.roomName].intel) {
		const intel = Memory.rooms[this.roomName].intel;
		const lairs = intel.structures[STRUCTURE_KEEPER_LAIR];
		if (lairs) {
			this.memory.lairs = {};
			for (let id in lairs) {
				this.memory.lairs[id] = {
					paths: {},
				};

				// @todo Also save associated resources.
			}
		}
	}

	// Collect sources belonging to lairs.
	if ((this.memory.lairs && !this.memory.sourcesChecked) || this.memory.sourcesChecked < Game.time - 6542) {
		let found = false;
		for (let id in this.memory.lairs) {
			const lair = Game.getObjectById(id);
			if (!lair) break;

			// Check sources.
			const sources = lair.pos.findInRange(FIND_SOURCES, 7);
			if (sources.length < 1) {
				sources = lair.pos.findInRange(FIND_MINERALS, 7);
			}

			for (let i in sources) {
				this.memory.lairs[id].source = sources[i].id;
				this.memory.lairs[id].sourceType = sources[i].mineralType || RESOURCE_ENERGY;
				break;
			}

			found = true;
		}

		if (found) {
			this.memory.sourcesChecked = Game.time;
		}
	}

	// Cache paths around the room.
	this.calculatePaths();

	// Save closest lair to entrance point.
	if (this.memory.lairs && this.memory.pathToRoom && !this.memory.closestLairToEntrance) {
		const lastPos = utilities.decodePosition(this.memory.pathToRoom[this.memory.pathToRoom.length - 1]);
		let bestRange = null;
		let best = null;
		for (let id in this.memory.lairs) {
			const lair = Game.getObjectById(id);
			if (lair && (!best || lastPos.getRangeTo(lair) < bestRange)) {
				best = id;
				bestRange = lastPos.getRangeTo(lair);
			}
		}

		if (best) {
			this.memory.closestLairToEntrance = best;
		}
	}

	// Try and build roads where needed.
	this.buildRoads();
};

Exploit.prototype.buildRoads = function () {
	if (!this.memory.lastRoadCheck || (this.memory.lastRoadCheck < Game.time - 51 && _.size(Game.constructionSites) < 75)) {
		if (Game.rooms[this.roomName]) {
			const room = Game.rooms[this.roomName];
			const sites = room.find(FIND_CONSTRUCTION_SITES);
			let numSites = sites.length;
			this.memory.lastRoadCheck = Game.time;

			if (this.memory.pathToRoom) {
				for (let i in this.memory.pathToRoom) {
					if (numSites >= 10) return;
					const pos = utilities.decodePosition(this.memory.pathToRoom[i]);
					if (pos.roomName !== this.roomName) continue;

					const structures = pos.lookFor(LOOK_STRUCTURES);
					const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

					if (structures.length > 0 || sites.length > 0) continue;
					if (pos.createConstructionSite(STRUCTURE_ROAD) === OK) {
						numSites++;
					}
				}
			}

			if (this.memory.lairs) {
				for (id in this.memory.lairs) {
					if (this.memory.lairs[id].sourcePath) {
						const path = this.memory.lairs[id].sourcePath.path;
						for (let i in path) {
							if (numSites >= 10) return;
							const pos = utilities.decodePosition(path[i]);

							const structures = pos.lookFor(LOOK_STRUCTURES);
							const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

							if (sites.length > 0) continue;
							if (_.filter(structures, (s) => s.structureType == STRUCTURE_ROAD).length == 0) {
								if (pos.createConstructionSite(STRUCTURE_ROAD) == OK) {
									numSites++;
								}
							}

							// Build containers close to sources.
							if (i == path.length - 2 && _.filter(structures, (s) => s.structureType == STRUCTURE_CONTAINER).length == 0) {
								if (pos.createConstructionSite(STRUCTURE_CONTAINER) == OK) {
									numSites++;
								}
							}
						}
					}

					for (id2 in this.memory.lairs) {
						if (this.memory.lairs[id].paths[id2] && this.memory.lairs[id].paths[id2].path) {
							let path = this.memory.lairs[id].paths[id2].path;
							for (let i in path) {
								if (numSites >= 10) return;
								let pos = utilities.decodePosition(path[i]);

								let structures = pos.lookFor(LOOK_STRUCTURES);
								let sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

								if (structures.length > 0 || sites.length > 0) continue;
								if (pos.createConstructionSite(STRUCTURE_ROAD) == OK) {
									numSites++;
								}
							}
						}
					}
				}
			}
		}
	}
};

Exploit.prototype.calculatePaths = function () {
	// Calculate path into room.
	if (!this.memory.pathToRoom || !this.memory.pathToRoomCalculated || this.memory.pathToRoomCalculated < Game.time - 10000) {
		var startPosition = this.sourceRoom.getStorageLocation();
		startPosition = new RoomPosition(startPosition.x, startPosition.y, this.sourceRoom.name);
		if (this.sourceRoom.storage) {
			startPosition = this.sourceRoom.storage.pos;
		}

		var endPosition = new RoomPosition(25, 25, this.flag.pos.roomName);

		var result = utilities.getPath(startPosition, {pos: endPosition, range: 20});

		if (result) {
			//console.log('found path in', result.ops, 'operations', result.path);

			this.memory.pathToRoom = utilities.serializePositionPath(result.path);
			this.memory.pathToRoomCalculated = Game.time;
			delete this.memory.closestLairToEntrance;
		}
		else {
			console.log('No path found!');
		}
		return;
	}

	for (let id in this.memory.lairs) {
		// Calculate paths between source keeper lairs.
		for (let id2 in this.memory.lairs) {
			if (id == id2) continue;
			if (this.memory.lairs[id].paths[id2]) continue;

			var lair = Game.getObjectById(id);
			var lair2 = Game.getObjectById(id2);

			if (!lair || !lair2) continue;

			var result = utilities.getPath(lair.pos, {pos: lair2.pos, range: 1});

			if (result) {
				this.memory.lairs[id].paths[id2] = {
					path: utilities.serializePositionPath(result.path),
					lastCalculated: Game.time,
				};
				this.memory.lairs[id2].paths[id] = {
					reverse: true,
					lastCalculated: Game.time,
				};
			}
			else {
				console.log('No path found!');
			}
			return;
		}

		// Calculate paths between lairs and actual sources.
		if (this.memory.lairs[id].source && !this.memory.lairs[id].sourcePath) {
			var lair = Game.getObjectById(id);
			var source = Game.getObjectById(this.memory.lairs[id].source);

			if (!lair || !source) continue;

			var result = utilities.getPath(lair.pos, {pos: source.pos, range: 1});

			if (result) {
				this.memory.lairs[id].sourcePath = {
					path: utilities.serializePositionPath(result.path),
					lastCalculated: Game.time,
				};
			}
			else {
				console.log('No path found!');
			}
			return;
		}
	}
};

Exploit.prototype.addSpawnOptions = function (options) {
	// Spawn a guardian that travels around the room to keep sources safe.
	let numGuardians = 0;
	if (this.units.guardian) {
		for (let i in this.units.guardian) {
			let creep = this.units.guardian[i];

			// Only counts if it has longer to live than it takes us to respawn and get a new creep there.
			if (!creep.ticksToLive || creep.ticksToLive > _.size(creep.body) * 3 + _.size(this.memory.pathToRoom) + 50) {
				numGuardians++;
			}
		}
	}

	if (numGuardians < 1) {
		// @todo Spawn in time to arrive when previous guardian expires.
		// @todo Only spawn guardian if room is protected by source keepers.
		options.push({
			role: 'exploit',
			priority: 3,
			weight: 1,
			subRole: 'guardian',
			exploit: this.name,
		});
	}

	// When necessary, spawn a builder to create a road network and containers.
	let numSites = _.size(_.filter(Game.constructionSites, (site) => site.pos.roomName == this.roomName));
	let maxBuilders = Math.ceil(numSites / 7);

	if (maxBuilders <= 0) {
		// Send a builder if containers are decaying too much.
		if (this.memory.lairs) {
			for (let id in this.memory.lairs) {
				let source = Game.getObjectById(this.memory.lairs[id].source);
				if (source) {
					let container = source.getNearbyContainer();
					if (container && container.hits < container.hitsMax * 0.5) {
						maxBuilders = 1;
						break;
					}
				}
			}
		}
	}

	if (numSites > 0 && _.size(_.filter(this.units['builder'], creep => creep.ticksToLive && creep.ticksToLive > (_.size(creep.body) * 3) + _.size(this.memory.pathToRoom) + 50)) < maxBuilders) {
		// @todo Maybe even spawn 2 builders when roads are still being built, but only use 1 when doing repairs.
		options.push({
			role: 'exploit',
			priority: 3,
			weight: 0.5,
			subRole: 'builder',
			exploit: this.name,
		});
	}

	// Once containers are build, send harvesters.
	if (this.memory.lairs) {
		let activeLairs = 0;
		let activeLairPathLength = 0;
		const roomPathLength = _.size(this.memory.pathToRoom);

		for (let id in this.memory.lairs) {
			const source = Game.getObjectById(this.memory.lairs[id].source);
			if (!source || !source.getNearbyContainer()) continue;

			// Regenerating mineral sources are also considered inactive.
			if (source.mineralType && source.mineralAmount <= 0) continue;

			activeLairs++;
			activeLairPathLength += roomPathLength;
			if (id !== this.memory.closestLairToEntrance) {
				const id2 = this.memory.closestLairToEntrance;
				if (this.memory.lairs[id].paths[id2]) {
					activeLairPathLength += _.size(this.memory.lairs[id].paths[id2].path);
					activeLairPathLength += _.size(this.memory.lairs[id2].paths[id].path);
				}
			}

			let numHarvesters = 0;
			if (this.units.harvester) {
				numHarvesters += _.filter(this.units.harvester, creep => creep.memory.fixedSource === source.id && (!creep.ticksToLive || creep.ticksToLive > (_.size(creep.body) * 3) + _.size(this.memory.pathToRoom) + 20)).length;
			}

			if (numHarvesters < 1) {
				options.push({
					role: 'exploit',
					priority: 3,
					weight: 0.1,
					subRole: 'harvester',
					exploit: this.name,
					source: source.id,
					resourceType: source.mineralType || RESOURCE_ENERGY,
				});
			}
		}

		const production = activeLairs * 4500 / 300;
		const productionAfterRoundTrip = 2 * activeLairPathLength * production;
		const neededWorkParts = productionAfterRoundTrip / 50;

		let totalWorkParts = 0;
		if (this.units.hauler) {
			for (let i in this.units.hauler) {
				totalWorkParts += this.units.hauler[i].memory.body.carry || 0;
			}
		}

		if (totalWorkParts < neededWorkParts * 0.5) { // Conservative for now.
			options.push({
				role: 'exploit',
				priority: 3,
				weight: 0,
				subRole: 'hauler',
				exploit: this.name,
			});
		}
	}
};

Exploit.prototype.spawnUnit = function (spawn, option) {
	if (option.subRole === 'guardian') {
		spawn.createManagedCreep({
			role: 'brawler',
			body: [
				MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE,
				MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE,
				MOVE, MOVE, MOVE, MOVE, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK,
				ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK,
				ATTACK, ATTACK, ATTACK, ATTACK, MOVE, HEAL, HEAL, HEAL, HEAL, HEAL
			],
			memory: {
				exploitName: this.name,
				exploitUnitType: 'guardian',
			},
		});
	}
	else if (option.subRole === 'builder') {
		spawn.createManagedCreep({
			role: 'builder.exploit',
			bodyWeights: {move: 0.4, carry: 0.3, work: 0.3},
			memory: {
				exploitName: this.name,
				exploitUnitType: 'builder',
			},
		});
	}
	else if (option.subRole === 'harvester') {
		const config = {
			role: 'harvester.exploit',
			bodyWeights: {move: 0.35, carry: 0.15, work: 0.5},
			memory: {
				exploitName: this.name,
				exploitUnitType: 'harvester',
				fixedSource: option.source,
			},
		};

		if (option.resourceType === RESOURCE_ENERGY) {
			config.maxParts = {work: 9};
		}

		spawn.createManagedCreep(config);
	}
	else if (option.subRole === 'hauler') {
		spawn.createManagedCreep({
			role: 'hauler.exploit',
			bodyWeights: {move: 0.35, carry: 0.65},
			memory: {
				exploitName: this.name,
				exploitUnitType: 'hauler',
			},
		});
	}

	return true;
};

module.exports = Exploit;
