/* global FIND_DROPPED_RESOURCES */

import Role from './role';

const ExploitHaulerRole = function () {
	Role.call(this);
};

ExploitHaulerRole.prototype = Object.create(Role.prototype);

/**
 * Makes a creep behave like an exploit harvester.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitHaulerRole.prototype.run = function (creep) {
	if (!creep.memory.harvesting && _.sum(creep.carry) <= 0) {
		this.setExploitHaulerState(creep, true);
	}
	else if (creep.memory.harvesting && _.sum(creep.carry) >= creep.carryCapacity * 0.9) {
		this.setExploitHaulerState(creep, false);
	}

	if (creep.memory.harvesting) {
		this.performExploitCollect(creep);
		return;
	}

	this.performExploitHaulerDeliver(creep);
};

/**
 * Puts this creep into or out of collecting mode.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 * @param {boolean} collecting
 *   Whether this creep should be picking up or delivering.
 */
ExploitHaulerRole.prototype.setExploitHaulerState = function (creep, collecting) {
	creep.memory.harvesting = collecting;
	delete creep.memory.resourceTarget;
	delete creep.memory.pickupResources;
};

/**
 * Makes the creep gather resources in the current room.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitHaulerRole.prototype.performExploitCollect = function (creep) {
	// Always pick up nearby resources.
	const dropped = creep.pos.findInRange(FIND_DROPPED_RESOURCES, 1);
	if (dropped.length > 0) {
		creep.pickup(dropped[0]);
	}

	const exploit = Game.exploits[creep.memory.exploitName];
	if (!exploit) return;

	// Follow cached path when requested.
	if (creep.hasCachedPath()) {
		creep.followCachedPath();
		if (creep.hasArrived()) {
			creep.clearCachedPath();

			if (creep.memory.travellingToRoom) {
				// Next, find and travel to destined source.
				if (exploit.memory.closestLairToEntrance) {
					creep.memory.currentLair = exploit.memory.closestLairToEntrance;
				}
				else if (exploit.memory.lairs) {
					creep.memory.currentLair = _.keys(exploit.memory.lairs)[0];
				}

				this.setExploitHaulerTargetSource(creep);
				delete creep.memory.travellingToRoom;
			}
		}
	}
	else if (this.pos.roomName !== exploit.roomName && exploit.memory.pathToRoom) {
		creep.setCachedPath(exploit.memory.pathToRoom, false, 1);
		creep.memory.travellingToRoom = true;
		delete creep.memory.currentLair;
	}
	else if (creep.memory.pickupResources) {
		const source: Source = Game.getObjectById(exploit.memory.lairs[creep.memory.currentLair].source);
		const container = source.getNearbyContainer();
		if (!container) {
			const resources = creep.pos.findInRange(FIND_DROPPED_RESOURCES, 3);
			if (resources.length <= 0) {
				delete creep.memory.pickupResources;
				return;
			}

			if (creep.pos.getRangeTo(resources[0]) > 1) {
				creep.moveToRange(resources[0], 1);
			}
			else {
				creep.pickup(resources[0]);
			}

			return;
		}

		if (creep.pos.getRangeTo(container) > 1) {
			creep.moveTo(container);
		}
		else if (_.sum(container.store) > 0) {
			for (const resourceType in container.store) {
				if (container.store[resourceType] > 0) {
					creep.withdraw(container, resourceType);
					break;
				}
			}
		}
		else {
			delete creep.memory.pickupResources;
		}
	}
	else {
		// Set target source.
		this.setExploitHaulerTargetSource(creep);
	}
};

/**
 * Chooses a reasonable source container to collect resources from.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitHaulerRole.prototype.setExploitHaulerTargetSource = function (creep: Creep) {
	const exploit = Game.exploits[creep.memory.exploitName];

	if (!exploit.memory.lairs) return;

	if (!creep.memory.currentLair || !exploit.memory.lairs[creep.memory.currentLair]) {
		creep.memory.currentLair = exploit.memory.closestLairToEntrance;
	}

	for (const id of _.keys(exploit.memory.lairs)) {
		const lairData = exploit.memory.lairs[id];
		if (!lairData.source) continue;

		const source: Source = Game.getObjectById(lairData.source);
		if (!source) continue;

		const container = source.getNearbyContainer();
		// @todo Calculate threshhold when to collect resources.
		if (!container || _.sum(container.store) < 500) continue;

		// Check if other haulers are going for this already.
		const haulers = creep.room.creepsByRole['hauler.exploit'];
		let numInboundHaulers = 0;
		for (const hauler of _.values<Creep>(haulers)) {
			if (hauler.id === creep.id) continue;

			if (hauler.memory.pickupResources && hauler.memory.currentLair === id) {
				numInboundHaulers++;
			}
		}

		if (numInboundHaulers === 0 || (numInboundHaulers === 1 && _.sum(container.store) >= 1200)) {
			// Plot a path to the target lair.
			if (creep.memory.currentLair !== id) {
				const path = exploit.memory.lairs[creep.memory.currentLair].paths[id];
				if (path && path.path) {
					creep.setCachedPath(exploit.memory.lairs[creep.memory.currentLair].paths[id].path, false, 3);
				}
				else if (path) {
					creep.setCachedPath(lairData.paths[creep.memory.currentLair].path, true, 3);
				}

				creep.memory.currentLair = id;
			}

			creep.memory.pickupResources = true;
			return;
		}
	}

	// Seems like no source has enough energy yet.
	this.chooseRandomExploitHaulerTargetSource(creep);
};

/**
 * Makes hauler travel to a random active source so we don't block the entrance.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitHaulerRole.prototype.chooseRandomExploitHaulerTargetSource = function (creep) {
	const exploit = Game.exploits[creep.memory.exploitName];
	const id = _.sample(_.filter(_.keys(exploit.memory.lairs), id => {
		const lair = exploit.memory.lairs[id];
		const source = Game.getObjectById(lair.source);
		if (source) {
			return true;
		}

		return false;
	}));
	const path = exploit.memory.lairs[creep.memory.currentLair].paths[id];
	if (!path) return;

	if (path.path) {
		creep.setCachedPath(exploit.memory.lairs[creep.memory.currentLair].paths[id].path, false, 3);
	}
	else {
		creep.setCachedPath(exploit.memory.lairs[id].paths[creep.memory.currentLair].path, true, 3);
	}

	creep.memory.currentLair = id;
	creep.memory.pickupResources = true;
};

/**
 * Dumps minerals a harvester creep has gathered.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitHaulerRole.prototype.performExploitHaulerDeliver = function (creep) {
	const exploit = Game.exploits[creep.memory.exploitName];
	if (!exploit) return;

	// Follow cached path when requested.
	if (creep.hasCachedPath()) {
		creep.followCachedPath();
		if (creep.hasArrived()) {
			creep.clearCachedPath();
			creep.memory.travellingToRoom = false;
		}
	}
	else if (creep.pos.roomName === exploit.roomName && exploit.memory.pathToRoom) {
		// @todo Make sure we've moved to the entrance lair first.
		const currentLair = creep.memory.currentLair;
		const closestLair = exploit.memory.closestLairToEntrance;
		if (currentLair && currentLair !== closestLair) {
			const path = exploit.memory.lairs[currentLair].paths[closestLair];
			if (path) {
				if (path.path) {
					creep.setCachedPath(exploit.memory.lairs[currentLair].paths[closestLair].path, false, 3);
				}
				else {
					creep.setCachedPath(exploit.memory.lairs[closestLair].paths[currentLair].path, true, 3);
				}

				creep.memory.currentLair = closestLair;
				return;
			}
		}

		creep.setCachedPath(exploit.memory.pathToRoom, true, 3);
		creep.memory.travellingToRoom = true;
		delete creep.memory.currentLair;
	}
	else {
		let resourceType;
		let amount;
		for (const type in creep.carry) {
			if (!resourceType || creep.carry[type] > amount) {
				amount = creep.carry[type];
				resourceType = type;
			}
		}

		const target = creep.room.getBestStorageTarget(amount, resourceType);
		if (creep.pos.getRangeTo(target) > 1) {
			creep.moveToRange(target, 1);
		}
		else {
			creep.transferAny(target);
		}
	}
};

export default ExploitHaulerRole;
