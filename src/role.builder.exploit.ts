/* global FIND_DROPPED_RESOURCES RESOURCE_ENERGY FIND_SOURCES_ACTIVE
FIND_STRUCTURES FIND_MY_CONSTRUCTION_SITES */

import utilities from './utilities';
import Role from './role';
import BuilderRole from './role.builder';

const ExploitBuilderRole = function () {
	Role.call(this);

	this.builderRole = new BuilderRole();
};

ExploitBuilderRole.prototype = Object.create(Role.prototype);

/**
 * Makes a creep behave like an exploit builder.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitBuilderRole.prototype.run = function (creep) {
	if (creep.memory.building && creep.carry.energy === 0) {
		this.setExploitBuilderState(creep, false);
	}
	else if (!creep.memory.building && creep.carry.energy === creep.carryCapacity) {
		this.setExploitBuilderState(creep, true);
	}

	const exploit = Game.exploits[creep.memory.exploitName];
	if (exploit) {
		// Follow cached path when requested.
		if (creep.hasCachedPath()) {
			creep.followCachedPath();
			if (creep.hasArrived()) {
				creep.clearCachedPath();
			}
			else {
				return;
			}
		}
		else if (creep.pos.roomName !== exploit.roomName && exploit.memory.pathToRoom) {
			creep.setCachedPath(exploit.memory.pathToRoom, false, 3);
			return;
		}
	}

	if (creep.memory.building) {
		this.performExploitBuild(creep);
		return;
	}

	this.performGetExploitEnergy(creep);
};

/**
 * Puts this creep into or out of build mode.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 * @param {boolean} building
 *   Whether to start building or not.
 */
ExploitBuilderRole.prototype.setExploitBuilderState = function (creep, building) {
	creep.memory.building = building;
	delete creep.memory.buildTarget;
	delete creep.memory.resourceTarget;
};

/**
 * Makes the creep use energy to finish construction sites in the current room.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitBuilderRole.prototype.performExploitBuild = function (creep) {
	// Repair structures around the room when necessary.
	if (!creep.memory.repairTarget && Game.time % 10 === 0) {
		const structure = creep.pos.findClosestByRange(FIND_STRUCTURES, {
			filter: structure => structure.hits && structure.hits < structure.hitsMax * 0.5,
		});

		if (structure) {
			creep.memory.repairTarget = structure.id;
			delete creep.memory.buildTarget;
		}
	}

	if (creep.memory.repairTarget) {
		const target: AnyOwnedStructure = Game.getObjectById(creep.memory.repairTarget);
		if (target) {
			if (target.hits >= target.hitsMax) {
				delete creep.memory.repairTarget;
			}
			else if (creep.pos.getRangeTo(target) > 3) {
				creep.moveToRange(target, 3);
				if (Game.cpu.bucket > 5000) {
					this.builderRole.repairNearby(creep);
				}
			}
			else {
				creep.repair(target);
			}

			return;
		}

		delete creep.memory.repairTarget;
	}

	// Build stuff in the room.
	if (!creep.memory.buildTarget) {
		const targets = creep.room.find(FIND_MY_CONSTRUCTION_SITES);
		if (targets.length <= 0) {
			return;
		}

		creep.memory.buildTarget = utilities.getClosest(creep, targets);
	}

	const best = creep.memory.buildTarget;
	if (!best) {
		return;
	}

	const target = Game.getObjectById(best);
	if (!target) {
		creep.memory.buildTarget = null;
		return;
	}

	if (creep.pos.getRangeTo(target) > 3) {
		creep.moveToRange(target, 3);
		if (Game.cpu.bucket > 5000) {
			this.builderRole.repairNearby(creep);
		}
	}
	else {
		creep.build(target);
	}
};

/**
 * Gathers energy while on an exploit operation.
 *
 * @param {Creep} creep
 *   The creep to run logic for.
 */
ExploitBuilderRole.prototype.performGetExploitEnergy = function (creep) {
	// Find nearby energy on the ground.
	if (!creep.memory.energyTarget) {
		const energy = creep.pos.findInRange(FIND_DROPPED_RESOURCES, 3, {
			filter: energy => energy.amount > creep.carryCapacity * 0.3 && energy.resourceType === RESOURCE_ENERGY,
		});
		if (energy.length > 0) {
			// Cache target energy to avoid ping-pong between it and target source.
			creep.memory.energyTarget = energy[0].id;
		}
	}

	if (creep.memory.energyTarget) {
		const energy = Game.getObjectById(creep.memory.energyTarget);
		if (energy) {
			if (creep.pos.getRangeTo(energy) > 1) {
				creep.moveToRange(energy, 1);
			}
			else {
				creep.pickup(energy);
			}

			return;
		}

		delete creep.memory.energyTarget;
	}

	// Harvest from safe sources.
	const source = creep.pos.findClosestByRange(FIND_SOURCES_ACTIVE, {
		filter: source => !source.isDangerous(),
	});

	if (!source) return;

	const container = source.getNearbyContainer();
	if (container && container.store.energy > creep.carryCapacity * 0.5) {
		if (creep.pos.getRangeTo(container) > 1) {
			creep.moveToRange(container, 1);
		}
		else {
			creep.withdraw(container, RESOURCE_ENERGY);
		}

		return;
	}

	if (creep.pos.getRangeTo(source) > 1) {
		creep.moveToRange(source, 1);
	}
	else {
		creep.harvest(source);
	}
};

export default ExploitBuilderRole;
