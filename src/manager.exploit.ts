/* global RoomPosition COLOR_RED STRUCTURE_KEEPER_LAIR FIND_SOURCES
RESOURCE_ENERGY FIND_CONSTRUCTION_SITES LOOK_STRUCTURES LOOK_CONSTRUCTION_SITES
STRUCTURE_ROAD OK STRUCTURE_CONTAINER FIND_MINERALS */

declare global {
	interface Memory {
		exploits: any,
	}

	interface CreepMemory {
		exploitUnitType: string,
	}
}

import hivemind from './hivemind';
import utilities from './utilities';

/**
 * Manages an exploit operation for source keeper rooms.
 * @constructor
 *
 * @param {Room} room
 *   The room that will spawn our creeps and reap the spoils of this operation.
 * @param {string} flagName
 *   Name of the flag pointing to the target source keeper room.
 */
const Exploit = function (room, flagName) {
	const flag = Game.flags[flagName];
	const roomName = flag.pos.roomName;
	this.units = {};
	this.name = roomName;
	this.roomName = roomName;
	this.flag = flag;

	this.sourceRoom = room;

	// Prepare memory
	if (!Memory.exploits) {
		Memory.exploits = {};
	}

	if (!Memory.exploits[roomName]) {
		Memory.exploits[roomName] = {};
	}

	this.memory = Memory.exploits[roomName];

	// Adjust flag color.
	if (this.flag.color !== COLOR_RED) {
		this.flag.setColor(COLOR_RED);
	}

	this.collectCreeps();
	this.collectLairs();
	this.collectSources();

	// Cache paths around the room.
	this.calculatePaths();

	// Save closest lair to entrance point.
	if (this.memory.lairs && this.memory.pathToRoom && !this.memory.closestLairToEntrance) {
		const lastPos = utilities.decodePosition(this.memory.pathToRoom[this.memory.pathToRoom.length - 1]);
		let bestRange = null;
		let best = null;
		for (const lairData of this.memory.lairs) {
			const lair: StructureKeeperLair = Game.getObjectById(lairData.id);
			if (lair && (!best || lastPos.getRangeTo(lair.pos) < bestRange)) {
				best = lairData.id;
				bestRange = lastPos.getRangeTo(lair.pos);
			}
		}

		if (best) {
			this.memory.closestLairToEntrance = best;
		}
	}

	// Try and build roads where needed.
	this.buildRoads();
};

/**
 * Collects creeps from temp data.
 */
Exploit.prototype.collectCreeps = function () {
	if (Game.exploitTemp && Game.exploitTemp[this.name]) {
		for (const id of Game.exploitTemp[this.name]) {
			const creep: Creep = Game.getObjectById(id);

			if (!this.units[creep.memory.exploitUnitType]) {
				this.units[creep.memory.exploitUnitType] = [];
			}

			this.units[creep.memory.exploitUnitType].push(creep);
		}
	}
};

/**
 * Collects source keeper lair positions.
 */
Exploit.prototype.collectLairs = function () {
	// @toto Update to roomIntel api.
	if (!this.memory.lairs && Memory.rooms[this.roomName] && Memory.rooms[this.roomName].intel) {
		const intel = Memory.rooms[this.roomName].intel;
		const lairs = intel.structures[STRUCTURE_KEEPER_LAIR];
		if (lairs) {
			this.memory.lairs = [];
			for (const id of _.keys(lairs)) {
				this.memory.lairs.push({
					id,
					paths: {},
				});
			}
		}
	}
};

/**
 * Collects sources belonging to lairs.
 */
Exploit.prototype.collectSources = function () {
	if (!this.memory.lairs) return;
	if (this.memory.sourcesChecked && !hivemind.hasIntervalPassed(5000, this.memory.sourcesChecked)) return;

	let found = false;
	for (const lairData of this.memory.lairs) {
		const lair = Game.getObjectById(lairData.id);
		if (!lair) break;

		// Check sources.
		let sources = lair.pos.findInRange(FIND_SOURCES, 7);
		if (sources.length === 0) {
			sources = lair.pos.findInRange(FIND_MINERALS, 7);
		}

		for (const source of sources) {
			lairData.source = source.id;
			lairData.sourceType = source.mineralType || RESOURCE_ENERGY;
			break;
		}

		found = true;
	}

	if (found) {
		this.memory.sourcesChecked = Game.time;
	}
};

/**
 * Builds roads in the exploited room.
 */
Exploit.prototype.buildRoads = function () {
	if (this.memory.lastRoadCheck && !hivemind.hasIntervalPassed(50, this.memory.lastRoadCheck)) return;
	if (_.size(Game.constructionSites) > 75) return;
	if (!Game.rooms[this.roomName]) return;

	const room = Game.rooms[this.roomName];
	this.numConstructionSites = room.find(FIND_CONSTRUCTION_SITES).length;
	this.memory.lastRoadCheck = Game.time;

	this.buildRoadsForPath(this.memory.pathToRoom);

	if (!this.memory.lairs) return;
	const lairMemory = this.memory.lairs;

	for (const lairData of lairMemory) {
		this.buildRoadsForPath(lairData.sourcePath && lairData.sourcePath.path, true);

		for (const id2 of _.map(lairMemory, 'id')) {
			this.buildRoadsForPath(lairData.paths[id2] && lairData.paths[id2].path);
		}
	}
};

/**
 * Builds roads along a given path, optionally with container at the end.
 *
 * @param {string[]} path
 *   An array of encoded room positions.
 * @param {boolean} addContainer
 *   Whether to build a container near the end of the path.
 */
Exploit.prototype.buildRoadsForPath = function (path, addContainer) {
	if (!path) return;

	for (let i = 0; i < path.length; i++) {
		const pos = utilities.decodePosition(path[i]);
		if (pos.roomName !== this.roomName) continue;

		// Build containers close to sources.
		const buildContainer = addContainer && i === path.length - 2;
		if (!this.tryBuildRoad(pos, buildContainer)) return;
	}
};

/**
 * Tries to create a construction site for a road.
 *
 * This method checks if other structures or construction sites exist at this
 * position first, and created no more than 10 construction sites in the room.
 *
 * @param {RoomPosition} pos
 *   The position to create the construction site at.
 * @param {boolean} addContainer
 *   Whether to also build a container at this position.
 *
 * @return {boolean}
 *   True if further construction sites can be created.
 */
Exploit.prototype.tryBuildRoad = function (pos, addContainer) {
	const structures = _.groupBy(pos.lookFor(LOOK_STRUCTURES), 'structureType');
	const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

	if (sites.length > 0) return true;
	if (_.size(structures[STRUCTURE_ROAD]) === 0 && pos.createConstructionSite(STRUCTURE_ROAD) === OK) {
		this.numConstructionSites++;
	}

	if (addContainer && _.size(structures[STRUCTURE_CONTAINER]) === 0 && pos.createConstructionSite(STRUCTURE_CONTAINER) === OK) {
		this.numConstructionSites++;
	}

	return this.numConstructionSites < 10;
};

/**
 * Calculates paths needed in exploit room.
 */
Exploit.prototype.calculatePaths = function () {
	// Calculate path into room.
	if (!this.memory.pathToRoom || !this.memory.pathToRoomCalculated || hivemind.hasIntervalPassed(10000, this.memory.pathToRoomCalculated)) {
		const startLocation = this.sourceRoom.getStorageLocation();
		if (!startLocation) return;

		let startPosition = new RoomPosition(startLocation.x, startLocation.y, this.sourceRoom.name);
		if (this.sourceRoom.storage) {
			startPosition = this.sourceRoom.storage.pos;
		}

		const endPosition = new RoomPosition(25, 25, this.flag.pos.roomName);

		const result = utilities.getPath(startPosition, {pos: endPosition, range: 20});

		if (result) {
			this.memory.pathToRoom = utilities.serializePositionPath(result.path);
			this.memory.pathToRoomCalculated = Game.time;
			delete this.memory.closestLairToEntrance;
		}
		else {
			console.log('No path found!');
		}

		return;
	}

	const lairMemory = this.memory.lairs;
	for (const lairData of lairMemory) {
		// Calculate paths between source keeper lairs.
		for (const lairData2 of lairMemory) {
			if (lairData.id === lairData2.id) continue;
			if (lairData.paths[lairData2.id]) continue;

			const lair: StructureKeeperLair = Game.getObjectById(lairData.id);
			const lair2: StructureKeeperLair = Game.getObjectById(lairData2.id);

			if (!lair || !lair2) continue;

			const result = utilities.getPath(lair.pos, {pos: lair2.pos, range: 1});

			if (result) {
				lairData.paths[lairData2.id] = {
					path: utilities.serializePositionPath(result.path),
					lastCalculated: Game.time,
				};
				lairData2.paths[lairData.id] = {
					reverse: true,
					lastCalculated: Game.time,
				};
			}
			else {
				console.log('No path found!');
			}

			return;
		}

		// Calculate paths between lairs and actual sources.
		if (lairData.source && !lairData.sourcePath) {
			const lair: StructureKeeperLair = Game.getObjectById(lairData.id);
			const source: Source = Game.getObjectById(lairData.source);

			if (!lair || !source) continue;

			const result = utilities.getPath(lair.pos, {pos: source.pos, range: 1});

			if (result) {
				lairData.sourcePath = {
					path: utilities.serializePositionPath(result.path),
					lastCalculated: Game.time,
				};
			}
			else {
				console.log('No path found!');
			}

			return;
		}
	}
};

/**
 * Calculates status of sources and whether they may be harvested.
 *
 * @return {Object}
 *   Information about active sources.
 */
Exploit.prototype.calculateSourcesState = function () {
	const sourcesState = {
		pathLength: 0,
		sources: [],
	};

	// @todo Also calculate states if room has no lairs.
	if (!this.memory.lairs) return sourcesState;

	// Add data for all active sources.
	const roomPathLength = _.size(this.memory.pathToRoom);
	for (const lairData of this.memory.lairs) {
		const source: Source | Mineral = Game.getObjectById(lairData.source);
		if (!source || !source.getNearbyContainer()) continue;

		// Regenerating mineral sources are also considered inactive.
		if (source.mineralType && source.mineralAmount <= 0) continue;

		sourcesState.sources.push(source);
		sourcesState.pathLength += roomPathLength;
		if (lairData.id !== this.memory.closestLairToEntrance) {
			const id2 = this.memory.closestLairToEntrance;
			if (lairData.paths[id2] && lairData.paths[id2].path) {
				sourcesState.pathLength += _.size(lairData.paths[id2].path);
			}
			else {
				sourcesState.pathLength += _.size(this.memory.lairs[id2].paths[lairData.id].path);
			}
		}
	}

	return sourcesState;
};

export default Exploit;
