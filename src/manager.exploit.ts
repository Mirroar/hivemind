/* global RoomPosition COLOR_RED STRUCTURE_KEEPER_LAIR FIND_SOURCES
RESOURCE_ENERGY FIND_CONSTRUCTION_SITES LOOK_STRUCTURES LOOK_CONSTRUCTION_SITES
STRUCTURE_ROAD OK STRUCTURE_CONTAINER FIND_MINERALS */

import hivemind from 'hivemind';
import utilities from 'utilities';
import {getRoomIntel} from 'room-intel';
import {decodePosition, deserializePositionPath, serializePositionPath} from 'utils/serialization';

interface ExploitMemory {
	closestLairToEntrance?: Id<StructureKeeperLair>;
	lairs?: Array<{
		id: Id<StructureKeeperLair>;
		source?: Id<Source | Mineral>;
		sourceType?: ResourceConstant;
		paths: Record<string, {
			path?: Array<string | number>;
			reverse?: boolean;
			lastCalculated: number;
		}>;
		sourcePath?: {
			path: Array<string | number>;
			lastCalculated: number;
		};
	}>;
	sourcesChecked?: number;
	lastRoadCheck?: number;
	pathToRoomCalculated?: number;
	pathToRoom?: Array<string | number>;
}

declare global {
	interface Memory {
		exploits: Record<string, ExploitMemory>;
	}

	interface CreepMemory {
		exploitUnitType?: string;
	}
}

/**
 * Manages an exploit operation for source keeper rooms.
 * @constructor
 *
 * @param {Room} room
 *   The room that will spawn our creeps and reap the spoils of this operation.
 * @param {string} flagName
 *   Name of the flag pointing to the target source keeper room.
 */
export default class Exploit {
	units: Record<string, Creep[]>;
	name: string;
	roomName: string;
	flag: Flag;
	sourceRoom: Room;
	numConstructionSites: number;

	memory: ExploitMemory;

	constructor(room: Room, flagName: string) {
		const flag = Game.flags[flagName];
		const roomName = flag.pos.roomName;
		this.units = {};
		this.name = roomName;
		this.roomName = roomName;
		this.flag = flag;

		this.sourceRoom = room;

		// Prepare memory
		if (!Memory.exploits) {
			Memory.exploits = {};
		}

		if (!Memory.exploits[roomName]) {
			Memory.exploits[roomName] = {};
		}

		this.memory = Memory.exploits[roomName];

		// Adjust flag color.
		if (this.flag.color !== COLOR_RED) {
			this.flag.setColor(COLOR_RED);
		}

		this.collectCreeps();
		this.collectLairs();
		this.collectSources();

		// Cache paths around the room.
		this.calculatePaths();

		// Save closest lair to entrance point.
		if (this.memory.lairs && this.memory.pathToRoom && !this.memory.closestLairToEntrance) {
			const lastPos = deserializePositionPath(this.memory.pathToRoom)[this.memory.pathToRoom.length - 1];
			let bestRange = null;
			let best = null;
			for (const lairData of this.memory.lairs) {
				const lair = Game.getObjectById(lairData.id);
				if (lair && (!best || lastPos.getRangeTo(lair.pos) < bestRange)) {
					best = lairData.id;
					bestRange = lastPos.getRangeTo(lair.pos);
				}
			}

			if (best) {
				this.memory.closestLairToEntrance = best;
			}
		}

		// Try and build roads where needed.
		this.buildRoads();
	}

	/**
	 * Collects creeps from temp data.
	 */
	collectCreeps() {
		if (Game.exploitTemp && Game.exploitTemp[this.name]) {
			for (const id of Game.exploitTemp[this.name]) {
				const creep = Game.getObjectById<Creep>(id);

				if (!this.units[creep.memory.exploitUnitType]) {
					this.units[creep.memory.exploitUnitType] = [];
				}

				this.units[creep.memory.exploitUnitType].push(creep);
			}
		}
	}

	/**
	 * Collects source keeper lair positions.
	 */
	collectLairs() {
		const roomIntel = getRoomIntel(this.roomName);
		if (this.memory.lairs) return;

		const lairs = roomIntel.getStructures(STRUCTURE_KEEPER_LAIR);
		if (_.size(lairs) === 0) return;

		this.memory.lairs = [];
		for (const id of _.keys(lairs) as Array<Id<StructureKeeperLair>>) {
			this.memory.lairs.push({
				id,
				paths: {},
			});
		}
	}

	/**
	 * Collects sources belonging to lairs.
	 */
	collectSources() {
		if (!this.memory.lairs) return;
		if (this.memory.sourcesChecked && !hivemind.hasIntervalPassed(5000, this.memory.sourcesChecked)) return;

		let found = false;
		for (const lairData of this.memory.lairs) {
			const lair = Game.getObjectById<StructureKeeperLair>(lairData.id);
			if (!lair) break;

			// Check sources.
			let sources: Source[] | Mineral[] = lair.pos.findInRange(FIND_SOURCES, 7);
			if (sources.length === 0) {
				sources = lair.pos.findInRange(FIND_MINERALS, 7);
			}

			for (const source of sources) {
				lairData.source = source.id;
				lairData.sourceType = source instanceof Mineral ? source.mineralType : RESOURCE_ENERGY;
				break;
			}

			found = true;
		}

		if (found) {
			this.memory.sourcesChecked = Game.time;
		}
	}

	/**
	 * Builds roads in the exploited room.
	 */
	buildRoads() {
		if (this.memory.lastRoadCheck && !hivemind.hasIntervalPassed(50, this.memory.lastRoadCheck)) return;
		if (_.size(Game.constructionSites) > 75) return;
		if (!Game.rooms[this.roomName]) return;

		const room = Game.rooms[this.roomName];
		this.numConstructionSites = room.find(FIND_CONSTRUCTION_SITES).length;
		this.memory.lastRoadCheck = Game.time;

		this.buildRoadsForPath(this.memory.pathToRoom);

		if (!this.memory.lairs) return;
		const lairMemory = this.memory.lairs;

		for (const lairData of lairMemory) {
			this.buildRoadsForPath(lairData.sourcePath && lairData.sourcePath.path, true);

			for (const id of _.map<any, string>(lairMemory, 'id')) {
				this.buildRoadsForPath(lairData.paths[id] && lairData.paths[id].path);
			}
		}
	}

	/**
	 * Builds roads along a given path, optionally with container at the end.
	 *
	 * @param {string[]} path
	 *   An array of encoded room positions.
	 * @param {boolean} addContainer
	 *   Whether to build a container near the end of the path.
	 */
	buildRoadsForPath(path: Array<string | number>, addContainer?: boolean) {
		if (!path) return;
		const decodedPath = deserializePositionPath(path);

		for (let i = 0; i < decodedPath.length; i++) {
			const pos = decodedPath[i];
			if (pos.roomName !== this.roomName) continue;

			// Build containers close to sources.
			const buildContainer = addContainer && i === decodedPath.length - 2;
			if (!this.tryBuildRoad(pos, buildContainer)) return;
		}
	}

	/**
	 * Tries to create a construction site for a road.
	 *
	 * This method checks if other structures or construction sites exist at this
	 * position first, and created no more than 10 construction sites in the room.
	 *
	 * @param {RoomPosition} pos
	 *   The position to create the construction site at.
	 * @param {boolean} addContainer
	 *   Whether to also build a container at this position.
	 *
	 * @return {boolean}
	 *   True if further construction sites can be created.
	 */
	tryBuildRoad(pos: RoomPosition, addContainer?: boolean): boolean {
		const structures = _.groupBy(pos.lookFor(LOOK_STRUCTURES), 'structureType');
		const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

		if (sites.length > 0) return true;
		if (_.size(structures[STRUCTURE_ROAD]) === 0 && pos.createConstructionSite(STRUCTURE_ROAD) === OK) {
			this.numConstructionSites++;
		}

		if (addContainer && _.size(structures[STRUCTURE_CONTAINER]) === 0 && pos.createConstructionSite(STRUCTURE_CONTAINER) === OK) {
			this.numConstructionSites++;
		}

		return this.numConstructionSites < 10;
	}

	/**
	 * Calculates paths needed in exploit room.
	 */
	calculatePaths() {
		// Calculate path into room.
		if (!this.memory.pathToRoom || !this.memory.pathToRoomCalculated || hivemind.hasIntervalPassed(10_000, this.memory.pathToRoomCalculated)) {
			const startLocation = this.sourceRoom.getStorageLocation();
			if (!startLocation) return;

			let startPosition = new RoomPosition(startLocation.x, startLocation.y, this.sourceRoom.name);
			if (this.sourceRoom.storage) {
				startPosition = this.sourceRoom.storage.pos;
			}

			const endPosition = new RoomPosition(25, 25, this.flag.pos.roomName);

			const result = utilities.getPath(startPosition, {pos: endPosition, range: 20});

			if (result) {
				this.memory.pathToRoom = serializePositionPath(result.path);
				this.memory.pathToRoomCalculated = Game.time;
				delete this.memory.closestLairToEntrance;
			}
			else {
				console.log('No path found!');
			}

			return;
		}

		const lairMemory = this.memory.lairs;
		for (const lairData of lairMemory) {
			// Calculate paths between source keeper lairs.
			for (const lairData2 of lairMemory) {
				if (lairData.id === lairData2.id) continue;
				if (lairData.paths[lairData2.id]) continue;

				const lair = Game.getObjectById<StructureKeeperLair>(lairData.id);
				const lair2 = Game.getObjectById<StructureKeeperLair>(lairData2.id);

				if (!lair || !lair2) continue;

				const result = utilities.getPath(lair.pos, {pos: lair2.pos, range: 1});

				if (result) {
					lairData.paths[lairData2.id] = {
						path: serializePositionPath(result.path),
						lastCalculated: Game.time,
					};
					lairData2.paths[lairData.id] = {
						reverse: true,
						lastCalculated: Game.time,
					};
				}
				else {
					console.log('No path found!');
				}

				return;
			}

			// Calculate paths between lairs and actual sources.
			if (lairData.source && !lairData.sourcePath) {
				const lair = Game.getObjectById<StructureKeeperLair>(lairData.id);
				const source = Game.getObjectById<Source>(lairData.source);

				if (!lair || !source) continue;

				const result = utilities.getPath(lair.pos, {pos: source.pos, range: 1});

				if (result) {
					lairData.sourcePath = {
						path: serializePositionPath(result.path),
						lastCalculated: Game.time,
					};
				}
				else {
					console.log('No path found!');
				}

				return;
			}
		}
	}

	/**
	 * Calculates status of sources and whether they may be harvested.
	 *
	 * @return {Object}
	 *   Information about active sources.
	 */
	calculateSourcesState(): {pathLength: number; sources: Array<Source | Mineral>} {
		const sourcesState: {
			pathLength: number;
			sources: Array<Source | Mineral>;
		} = {
			pathLength: 0,
			sources: [],
		};

		// @todo Also calculate states if room has no lairs.
		if (!this.memory.lairs) return sourcesState;

		// Add data for all active sources.
		const roomPathLength = _.size(this.memory.pathToRoom);
		for (const lairData of this.memory.lairs) {
			const source = Game.getObjectById<Source | Mineral>(lairData.source);
			if (!source || !source.getNearbyContainer()) continue;

			// Regenerating mineral sources are also considered inactive.
			if (source instanceof Mineral && source.mineralAmount <= 0) continue;

			sourcesState.sources.push(source);
			sourcesState.pathLength += roomPathLength;
			if (lairData.id !== this.memory.closestLairToEntrance) {
				const id2 = this.memory.closestLairToEntrance;
				sourcesState.pathLength += lairData.paths[id2] && lairData.paths[id2].path ? _.size(lairData.paths[id2].path) : _.size(_.find(this.memory.lairs, l => l.id === id2).paths[lairData.id].path);
			}
		}

		return sourcesState;
	}
}
